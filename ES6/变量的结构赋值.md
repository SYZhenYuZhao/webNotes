# 变量的结构赋值

  近期在阅读Redux源码时发现，在ES6的语法中还是有好多记忆不是特别深刻的地方，所以决定重新对ES6的一些容易疏忽的点做下记录

## 数组的解构赋值

在解构赋值赋值的过程中存在以下几个情况:

```javascript
let [x,,y] = [1,2,3];
/*
* x = 1
* y = 2
* */
//...展开运算符
let [x,...container] = [1, 2, 3, 4, 5]
/**
 * x =1
 * container = [2, 3, 4, 5]
*/
// 普通变量如果解构不成功，其值等于undefined
//...被展开变量如果解构不成功，其值为空数组
let [x,y,...arr] = [1];
/**
 * x = 1
 * y = undefined
 * arr = []
*/
//如果解构的数值不含有Iterator接口 则抛出错误
```

## 解构过程中设置默认值

在解构过程中设置默认值，只需要理解和注意一点</br>
————只有当被解构的变量完全等于undefined时，默认值才会被赋值给变量

## 对象的解构赋值

在对象的解构赋值过程中，我们通常是这样写的

```javascript
    let {foo,bar} = {foo:'123',bar:'456'}
```

如果将上列式子完整的写出来就是:

```javascript
    let{foo:foo,bar:bar} = {foo:'123',bar:'456'}
```

在对象的解构赋值过程中，解构的 **键名** 必须和数据中的一致。**键值** 可以是任意变量名。 想当于我们将数据的值付给了解构过程中设置的 **键值** (变量)

## 函数解构过程中设置默认值

```javascript
    function move({x = 0, y = 0} = {}) {
        return [x, y];
    }

    move({x: 3, y: 8}); // [3, 8]
    move({x: 3}); // [3, 0]
    move({}); // [0, 0]
    move(); // [0, 0]
    // 如果不设置对象默认值为{}的话 ，会导致x,y的值从undefined中获取

    function move({x, y} = { x: 0, y: 0 }) {
        return [x, y];
    }

    move({x: 3, y: 8}); // [3, 8]
    move({x: 3}); // [3, undefined]
    move({}); // [undefined, undefined]
    move(); // [0, 0]

```